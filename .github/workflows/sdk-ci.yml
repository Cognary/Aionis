name: SDK CI

on:
  workflow_dispatch:
  pull_request:
    paths:
      - "packages/sdk/**"
      - "src/sdk/**"
      - "src/dev/sdk-*.ts"
      - "examples/rules_evaluate.sh"
      - "examples/tools_select.sh"
      - "scripts/sdk-release-check.sh"
      - "scripts/sdk-python-release-check.sh"
      - "scripts/docs-check.sh"
      - "docs/README.md"
      - "docs/SDK*.md"
      - ".github/workflows/sdk-ci.yml"
      - "package.json"
      - "package-lock.json"
      - "packages/python-sdk/**"
      - "src/dev/python-sdk-smoke.py"
  push:
    branches: ["main"]
    paths:
      - "packages/sdk/**"
      - "src/sdk/**"
      - "src/dev/sdk-*.ts"
      - "examples/rules_evaluate.sh"
      - "examples/tools_select.sh"
      - "scripts/sdk-release-check.sh"
      - "scripts/sdk-python-release-check.sh"
      - "scripts/docs-check.sh"
      - "docs/README.md"
      - "docs/SDK*.md"
      - ".github/workflows/sdk-ci.yml"
      - "package.json"
      - "package-lock.json"
      - "packages/python-sdk/**"
      - "src/dev/python-sdk-smoke.py"

jobs:
  sdk-validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: npm ci

      - name: Root build
        run: npm run -s build

      - name: SDK build
        run: npm run -s sdk:build

      - name: SDK release checks
        run: npm run -s sdk:release-check

      - name: Python SDK compile
        run: npm run -s sdk:py:compile

      - name: Python SDK release checks
        run: npm run -s sdk:py:release-check

      - name: SDK package dry-run
        run: npm run -s sdk:pack-dry-run

      - name: Docs check
        run: npm run -s docs:check

  sdk-capability-negotiation-smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 35
    strategy:
      fail-fast: false
      matrix:
        backend:
          - postgres
          - embedded
    env:
      DATABASE_URL: postgres://aionis:aionis@127.0.0.1:5432/aionis_memory
      PORT: "3101"
      ADMIN_TOKEN: ci-admin-token
      MEMORY_STORE_BACKEND: ${{ matrix.backend }}
      MEMORY_STORE_EMBEDDED_EXPERIMENTAL_ENABLED: ${{ matrix.backend == 'embedded' && 'true' || 'false' }}
      MEMORY_STORE_EMBEDDED_SNAPSHOT_MAX_BYTES: ${{ matrix.backend == 'embedded' && '12000' || '52428800' }}
      MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_ENABLED: "true"
      MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_MAX_ROUNDS: "8"
      MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED: "false"
      MEMORY_SHADOW_DUAL_WRITE_ENABLED: ${{ matrix.backend == 'embedded' && 'true' || 'false' }}
      MEMORY_SHADOW_DUAL_WRITE_STRICT: "false"
      MEMORY_STORE_EMBEDDED_RECALL_DEBUG_EMBEDDINGS_ENABLED: "false"
      MEMORY_STORE_EMBEDDED_RECALL_AUDIT_ENABLED: "true"
      MEMORY_STORE_EMBEDDED_SESSION_GRAPH_ENABLED: ${{ matrix.backend == 'embedded' && 'false' || 'true' }}
      MEMORY_STORE_EMBEDDED_PACK_EXPORT_ENABLED: ${{ matrix.backend == 'embedded' && 'false' || 'true' }}
      MEMORY_STORE_EMBEDDED_PACK_IMPORT_ENABLED: ${{ matrix.backend == 'embedded' && 'false' || 'true' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: npm ci

      - name: Prepare env file
        run: |
          cp .env.example .env
          {
            echo "DATABASE_URL=${DATABASE_URL}"
            echo "PORT=${PORT}"
            echo "ADMIN_TOKEN=${ADMIN_TOKEN}"
            echo "MEMORY_STORE_BACKEND=${MEMORY_STORE_BACKEND}"
            echo "MEMORY_STORE_EMBEDDED_EXPERIMENTAL_ENABLED=${MEMORY_STORE_EMBEDDED_EXPERIMENTAL_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_SNAPSHOT_MAX_BYTES=${MEMORY_STORE_EMBEDDED_SNAPSHOT_MAX_BYTES}"
            echo "MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_ENABLED=${MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_MAX_ROUNDS=${MEMORY_STORE_EMBEDDED_SNAPSHOT_COMPACTION_MAX_ROUNDS}"
            echo "MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED=${MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED}"
            echo "MEMORY_SHADOW_DUAL_WRITE_ENABLED=${MEMORY_SHADOW_DUAL_WRITE_ENABLED}"
            echo "MEMORY_SHADOW_DUAL_WRITE_STRICT=${MEMORY_SHADOW_DUAL_WRITE_STRICT}"
            echo "MEMORY_STORE_EMBEDDED_RECALL_DEBUG_EMBEDDINGS_ENABLED=${MEMORY_STORE_EMBEDDED_RECALL_DEBUG_EMBEDDINGS_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_RECALL_AUDIT_ENABLED=${MEMORY_STORE_EMBEDDED_RECALL_AUDIT_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_SESSION_GRAPH_ENABLED=${MEMORY_STORE_EMBEDDED_SESSION_GRAPH_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_PACK_EXPORT_ENABLED=${MEMORY_STORE_EMBEDDED_PACK_EXPORT_ENABLED}"
            echo "MEMORY_STORE_EMBEDDED_PACK_IMPORT_ENABLED=${MEMORY_STORE_EMBEDDED_PACK_IMPORT_ENABLED}"
          } >> .env

      - name: Start db
        run: docker compose up -d db

      - name: Wait for db
        run: |
          for i in {1..60}; do
            if docker compose exec -T db pg_isready -U aionis -d aionis_memory >/dev/null 2>&1; then
              exit 0
            fi
            sleep 2
          done
          echo "db not ready in time" >&2
          exit 1

      - name: Run migrations
        run: docker compose run --rm migrate

      - name: Build API
        run: npm run -s build

      - name: Shadow dual-write strict fail-fast guard (embedded)
        if: matrix.backend == 'embedded'
        run: |
          set +e
          timeout 15s env \
            MEMORY_SHADOW_DUAL_WRITE_ENABLED=true \
            MEMORY_SHADOW_DUAL_WRITE_STRICT=true \
            MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED=false \
            node dist/index.js >/tmp/sdk_ci_shadow_strict_guard.log 2>&1
          rc=$?
          set -e

          if [[ "${rc}" -eq 0 ]]; then
            echo "strict guard probe unexpectedly succeeded" >&2
            sed -n '1,220p' /tmp/sdk_ci_shadow_strict_guard.log >&2 || true
            exit 1
          fi

          if [[ "${rc}" -eq 124 ]]; then
            echo "strict guard probe timed out; expected immediate fail-fast" >&2
            sed -n '1,220p' /tmp/sdk_ci_shadow_strict_guard.log >&2 || true
            exit 1
          fi

          grep -q "MEMORY_SHADOW_DUAL_WRITE_STRICT=true requires MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED=true when MEMORY_STORE_BACKEND=embedded" \
            /tmp/sdk_ci_shadow_strict_guard.log || {
              echo "strict guard probe missing expected validation error" >&2
              sed -n '1,220p' /tmp/sdk_ci_shadow_strict_guard.log >&2 || true
              exit 1
            }

      - name: Shadow dual-write strict runtime hard-fail (embedded)
        if: matrix.backend == 'embedded'
        run: |
          set -euo pipefail

          API_PID=""
          cleanup() {
            if [[ -n "${API_PID}" ]]; then
              kill "${API_PID}" >/dev/null 2>&1 || true
              wait "${API_PID}" >/dev/null 2>&1 || true
            fi
            docker compose exec -T db psql -U aionis -d aionis_memory -c \
              "DO \$\$ BEGIN IF to_regclass('public.memory_commits_v2_ci_tmp') IS NOT NULL THEN EXECUTE 'ALTER TABLE memory_commits_v2_ci_tmp RENAME TO memory_commits_v2'; END IF; END \$\$;" \
              >/dev/null 2>&1 || true
          }
          trap cleanup EXIT

          table_exists="$(docker compose exec -T db psql -U aionis -d aionis_memory -Atc "SELECT to_regclass('public.memory_commits_v2') IS NOT NULL;")"
          if [[ "${table_exists}" != "t" ]]; then
            echo "memory_commits_v2 table missing before strict runtime probe" >&2
            exit 1
          fi

          docker compose exec -T db psql -U aionis -d aionis_memory -c \
            "ALTER TABLE memory_commits_v2 RENAME TO memory_commits_v2_ci_tmp;"

          env \
            MEMORY_SHADOW_DUAL_WRITE_ENABLED=true \
            MEMORY_SHADOW_DUAL_WRITE_STRICT=true \
            MEMORY_STORE_EMBEDDED_SHADOW_MIRROR_ENABLED=true \
            node dist/index.js >/tmp/sdk_ci_shadow_strict_runtime.log 2>&1 &
          API_PID=$!

          for i in {1..60}; do
            if curl -fsS "http://127.0.0.1:${PORT}/health" >/tmp/sdk_ci_shadow_strict_runtime_health.json 2>/dev/null; then
              break
            fi
            sleep 1
          done

          if [[ ! -s /tmp/sdk_ci_shadow_strict_runtime_health.json ]]; then
            echo "strict runtime probe API never became ready" >&2
            sed -n '1,220p' /tmp/sdk_ci_shadow_strict_runtime.log >&2 || true
            exit 1
          fi

          curl -sS -o /tmp/sdk_ci_shadow_strict_runtime_write.json -w "%{http_code}" \
            -X POST "http://127.0.0.1:${PORT}/v1/memory/write" \
            -H "content-type: application/json" \
            --data-binary @- >/tmp/sdk_ci_shadow_strict_runtime_status.txt <<'JSON'
          {
            "scope": "default",
            "actor": "ci",
            "input_text": "sdk-ci strict runtime mirror failure probe",
            "auto_embed": false,
            "nodes": [
              {
                "client_id": "sdk_ci_shadow_strict_runtime_probe",
                "type": "event",
                "text_summary": "strict runtime mirror failure probe"
              }
            ],
            "edges": []
          }
          JSON

          node -e '
            const fs = require("fs");
            const status = Number(fs.readFileSync("/tmp/sdk_ci_shadow_strict_runtime_status.txt", "utf8").trim());
            const body = JSON.parse(fs.readFileSync("/tmp/sdk_ci_shadow_strict_runtime_write.json", "utf8"));
            if (status !== 500) {
              throw new Error(`strict runtime probe expected 500, got ${status}`);
            }
            if (body.error !== "shadow_dual_write_strict_failure") {
              throw new Error(`strict runtime probe expected error=shadow_dual_write_strict_failure, got ${String(body.error)}`);
            }
            if (!body.details || body.details.capability !== "shadow_mirror_v2") {
              throw new Error("strict runtime probe expected details.capability=shadow_mirror_v2");
            }
            if (body.details.degraded_mode !== "mirror_failed") {
              throw new Error(`strict runtime probe expected details.degraded_mode=mirror_failed, got ${String(body.details.degraded_mode)}`);
            }
            if (body.details.failure_mode !== "soft_degrade") {
              throw new Error(`strict runtime probe expected details.failure_mode=soft_degrade, got ${String(body.details.failure_mode)}`);
            }
            if (body.details.fallback_applied !== false || body.details.strict !== true) {
              throw new Error("strict runtime probe expected fallback_applied=false and strict=true");
            }
          '

      - name: SDK capability negotiation smoke
        run: |
          node dist/index.js >/tmp/sdk_ci_api.log 2>&1 &
          API_PID=$!

          for i in {1..60}; do
            if curl -fsS "http://127.0.0.1:${PORT}/health" >/tmp/sdk_ci_health.json 2>/dev/null; then
              break
            fi
            sleep 1
          done

          if [[ ! -s /tmp/sdk_ci_health.json ]]; then
            echo "health endpoint never became ready" >&2
            sed -n '1,220p' /tmp/sdk_ci_api.log >&2 || true
            exit 1
          fi

          npm run -s sdk:smoke >/tmp/sdk_ci_smoke_ts.json
          npm run -s sdk:py:smoke >/tmp/sdk_ci_smoke_py.json

          node -e '
            const fs = require("fs");
            const expected = process.env.MEMORY_STORE_BACKEND;
            const port = process.env.PORT;
            const adminToken = process.env.ADMIN_TOKEN;
            const tsOut = JSON.parse(fs.readFileSync("/tmp/sdk_ci_smoke_ts.json", "utf8"));
            const pyOut = JSON.parse(fs.readFileSync("/tmp/sdk_ci_smoke_py.json", "utf8"));
            const ensure = (cond, msg) => { if (!cond) throw new Error(msg); };
            for (const [name, out] of [["ts", tsOut], ["py", pyOut]]) {
              ensure(out && out.ok === true, `${name} smoke must be ok=true`);
              ensure(out.calls && out.calls.health && out.calls.pack_export, `${name} smoke must include health + pack_export`);
            }
            if (expected === "embedded") {
              const tsCap = tsOut.calls.pack_export.capability_error;
              const pyCap = pyOut.calls.pack_export.capability_error;
              ensure(tsCap && tsCap.capability === "packs_export", "ts embedded must expose packs_export capability error");
              ensure(pyCap && pyCap.capability === "packs_export", "py embedded must expose packs_export capability error");
            } else {
              ensure(
                typeof tsOut.calls.pack_export.manifest_sha256 === "string" && tsOut.calls.pack_export.manifest_sha256.length > 0,
                "ts postgres must export pack manifest sha256",
              );
              ensure(
                typeof pyOut.calls.pack_export.manifest_sha256 === "string" && pyOut.calls.pack_export.manifest_sha256.length > 0,
                "py postgres must export pack manifest sha256",
              );
            }

            async function probeUnsupported(capability, path, payload) {
              const res = await fetch(`http://127.0.0.1:${port}${path}`, {
                method: "POST",
                headers: {
                  "content-type": "application/json",
                  "x-admin-token": adminToken,
                },
                body: JSON.stringify(payload),
              });
              let parsed = {};
              try {
                parsed = await res.json();
              } catch {
                throw new Error(`${capability} probe must return json`);
              }
              ensure(res.status === 501, `${capability} probe must return 501`);
              ensure(parsed.error === "backend_capability_unsupported", `${capability} probe must return backend_capability_unsupported`);
              ensure(parsed.details && parsed.details.capability === capability, `${capability} probe must include details.capability`);
              ensure(parsed.details && parsed.details.failure_mode === "hard_fail", `${capability} probe must include hard_fail mode`);
            }

            async function probeWriteSoftDegrade() {
              const payload = {
                scope: "default",
                actor: "ci",
                input_text: "sdk-ci shadow dual-write soft-degrade probe",
                auto_embed: false,
                nodes: [
                  {
                    client_id: `sdk_ci_shadow_soft_${Date.now()}`,
                    type: "event",
                    text_summary: "sdk ci shadow soft degrade",
                  },
                ],
                edges: [],
              };
              const res = await fetch(`http://127.0.0.1:${port}/v1/memory/write`, {
                method: "POST",
                headers: {
                  "content-type": "application/json",
                  "x-admin-token": adminToken,
                },
                body: JSON.stringify(payload),
              });
              let parsed = {};
              try {
                parsed = await res.json();
              } catch {
                throw new Error("shadow soft-degrade probe must return json");
              }
              ensure(res.status === 200, "shadow soft-degrade probe must return 200");
              const sdw = parsed.shadow_dual_write;
              ensure(sdw && typeof sdw === "object", "shadow soft-degrade probe must include shadow_dual_write");
              ensure(sdw.enabled === true, "shadow soft-degrade enabled must be true");
              ensure(sdw.strict === false, "shadow soft-degrade strict must be false");
              ensure(sdw.mirrored === false, "shadow soft-degrade mirrored must be false");
              ensure(sdw.capability === "shadow_mirror_v2", "shadow soft-degrade capability must be shadow_mirror_v2");
              ensure(sdw.failure_mode === "soft_degrade", "shadow soft-degrade failure_mode must be soft_degrade");
              ensure(sdw.degraded_mode === "capability_unsupported", "shadow soft-degrade degraded_mode must be capability_unsupported");
              ensure(sdw.fallback_applied === true, "shadow soft-degrade fallback_applied must be true");
            }

            (async () => {
              if (expected !== "embedded") return;
              await probeUnsupported("sessions_graph", "/v1/memory/sessions", {
                scope: "default",
                actor: "ci",
                session_id: `sdk_ci_sess_${Date.now()}`,
                auto_embed: false,
              });
              await probeUnsupported("packs_import", "/v1/memory/packs/import", {
                scope: "default",
                actor: "ci",
                verify_only: true,
                auto_embed: false,
                pack: {
                  version: "aionis_pack_v1",
                  tenant_id: "default",
                  scope: "default",
                  nodes: [],
                  edges: [],
                  commits: [],
                },
              });
              await probeWriteSoftDegrade();
            })().catch((err) => {
              console.error(err && err.message ? err.message : String(err));
              process.exit(1);
            });
          '

          kill "${API_PID}" || true
          wait "${API_PID}" || true

      - name: Diagnostics on failure
        if: failure()
        run: |
          docker compose ps || true
          docker compose logs --no-color db || true
          sed -n '1,220p' /tmp/sdk_ci_shadow_strict_guard.log || true
          sed -n '1,220p' /tmp/sdk_ci_shadow_strict_runtime.log || true
          cat /tmp/sdk_ci_shadow_strict_runtime_status.txt || true
          cat /tmp/sdk_ci_shadow_strict_runtime_write.json || true
          sed -n '1,220p' /tmp/sdk_ci_api.log || true
          cat /tmp/sdk_ci_smoke_ts.json || true
          cat /tmp/sdk_ci_smoke_py.json || true

      - name: Cleanup
        if: always()
        run: docker compose down -v
